<!DOCTYPE html>
<!-- 5-DOF Rocket Simulation Tutorial • Caledonian Rocketry -->
<html lang="en" x-data="guRocketryApp" :class="{ dark: darkMode }">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Build a 5-DOF Rocket Simulation • Caledonian Rocketry</title>

    <!-- Fonts & Tailwind -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com?plugins=typography,aspect-ratio"></script>

    <!-- AOS scroll animations -->
    <link rel="stylesheet" href="https://unpkg.com/aos@2.3.4/dist/aos.css" />
    <script src="https://unpkg.com/aos@2.3.4/dist/aos.js"></script>

    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script>
      document.addEventListener('alpine:init', () => {
        Alpine.data('guRocketryApp', () => ({ darkMode: true }));
      });
    </script>

    <!-- Colour tokens + prose helpers + star-field canvas -->
    <style>
      :root{ --rocket-red:#ff3131; --earth-brown:#8b5e3c; }
      body{font-family:'Inter',sans-serif}
      .accent-red{color:var(--rocket-red);}
      .accent-brown{color:var(--earth-brown);}
      .callout{background:rgba(31,41,55,.6);border-left:4px solid var(--rocket-red);
               padding:1rem;border-radius:.5rem;font-size:.875rem;color:#e5e7eb;margin:1.5rem 0;}
      pre code{display:block;background:rgba(17,24,39,.9);padding:1rem;border-radius:.375rem;
               color:#f3f4f6;overflow-x:auto;font-size:.75rem;line-height:1.625;}
      th,td{padding:.75rem 1rem;}
      .video-placeholder{background:rgba(31,41,55,.4);color:#e5e7eb;display:flex;
                         align-items:center;justify-content:center;height:200px;border-radius:.5rem;
                         margin:1rem 0;font-size:.875rem;}
      /* ★ star-field canvas */
      #starfield{position:fixed;inset:0;z-index:-1;background:#000;touch-action:none}
    </style>
  </head>

  <body x-data="{ hasAccess: localStorage.getItem('hasAccess') === 'true', email: '', institution: '', location: '', error: '' }"  class="bg-white dark:bg-gray-950 text-gray-900 dark:text-white antialiased scroll-smooth">

    <!-- ★ star-field backdrop -->
    <canvas id="starfield"></canvas>

    <!-- ====================== NAVBAR ====================== -->
    <header class="sticky top-0 z-50 backdrop-blur-lg/60 border-b border-gray-800 dark:border-gray-700" x-data="{open:false}">
      <div class="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
        <a href="index.html" class="text-xl font-extrabold tracking-tight accent-brown">Caledonian Rocketry</a>

        <!-- desktop links -->
   <nav class="hidden md:flex space-x-6 text-sm font-semibold">
  <!-- Anchors (same-page sections) -->
  <a href="index.html#mission" class="hover:text-red-500 transition">Mission</a>
  <a href="index.html#projects" class="hover:text-red-500 transition">Projects</a>
  <a href="index.html#tutorials" class="hover:text-red-500 transition">Tutorials</a>
  <a href="index.html#sponsors" class="hover:text-red-500 transition">Sponsors</a>
  <a href="index.html#contact"  class="hover:text-red-500 transition">Contact</a>


  <!-- External Pages -->
  <a href="MeetTeam.html" class="hover:text-red-500 transition">Team</a>
  <a href="Events.html" class="hover:text-red-500 transition">Events</a>
  <a href="certification.html" class="hover:text-red-500 transition">Certification</a>
  <a href="preliminaries.html"    class="hover:text-[color:var(--rocket-red)]">Preliminaries</a>
</nav>

        <!-- mobile burger -->
        <button @click="open=!open" class="md:hidden text-gray-100">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" stroke="currentColor">
            <path x-show="!open" stroke-linecap="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
            <path x-show="open"  stroke-linecap="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>

      <!-- mobile drawer -->
      <div x-show="open" x-transition class="md:hidden bg-gray-900 border-t border-gray-800">
        <ul class="flex flex-col items-center py-6 gap-6 text-lg font-semibold">
          <li><a href="index.html"             @click="open=false" class="hover:text-[color:var(--rocket-red)]">Home</a></li>
          <li><a href="Events.html"            @click="open=false" class="hover:text-[color:var(--rocket-red)]">Events</a></li>
          <li><a href="preliminaries.html"     @click="open=false" class="hover:text-[color:var(--rocket-red)]">Preliminaries</a></li>
          <li><a href="DeploymentTutorial.html"@click="open=false" class="text-[color:var(--rocket-red)]">Tutorials</a></li>
          <li><a href="certification.html"     @click="open=false" class="hover:text-[color:var(--rocket-red)]">Certifications</a></li>
        </ul>
      </div>
    </header>

    <!-- ====================== HERO ====================== -->
    <section class="pt-32 pb-20 bg-gradient-to-b from-black to-gray-900 text-center relative overflow-hidden">

        <h1 class="text-4xl md:text-5xl font-extrabold mb-3 accent-brown">How to Build a 5-DOF Rocket Simulation in&nbsp;Simulink</h1>
        <p class="text-gray-300">A practical, image-ready guide for rocketry students&nbsp;&amp;&nbsp;hobbyists</p>
      </div>
    </section>

    <!-- ====================== MAIN ====================== -->
    
<!-- 🚀 Access Control Wrapper -->
<div x-show="!hasAccess" class="min-h-screen flex items-center justify-center bg-black text-white px-6 py-20">
  <div class="max-w-md w-full bg-gray-900 rounded-xl shadow-lg p-8 space-y-4">
    <h2 class="text-2xl font-bold text-red-500">Access Required</h2>
    <p class="text-sm text-gray-400 mb-4">Please fill out this form to unlock the tutorial.</p>

    <form @submit.prevent="async () => {
        try {
            const res = await fetch('/api/leads', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, institution, location })
            });
            if (!res.ok) throw new Error('Submission failed');
            localStorage.setItem('hasAccess', 'true');
            hasAccess = true;
        } catch (e) {
            error = 'Something went wrong. Please try again.';
        }
    }" class="space-y-4">
      <input type="email" placeholder="Email" class="w-full p-2 bg-gray-800 border border-gray-700 rounded" x-model="email" required>
      <input type="text" placeholder="Institution" class="w-full p-2 bg-gray-800 border border-gray-700 rounded" x-model="institution" required>
      <input type="text" placeholder="Location" class="w-full p-2 bg-gray-800 border border-gray-700 rounded" x-model="location" required>
      <button type="submit" class="w-full bg-red-600 hover:bg-red-700 transition rounded py-2 font-semibold">Unlock Tutorial</button>
    </form>
    <p x-show="error" x-text="error" class="text-red-400 text-sm mt-2"></p>
  </div>
</div>

<!-- 🚀 Main Tutorial Content -->
<div x-show="hasAccess">
<main class="prose dark:prose-invert md:prose-lg max-w-4xl mx-auto px-4 py-16 prose-headings:font-semibold prose-headings:accent-brown">

      <!-- 0 · Why 5 DOF? -->
      <h2 id="why">0 · Why 5 DOF?</h2>
      <p>A 6-DOF model resolves all three rotations (roll φ, pitch θ, yaw ψ) and all three translations. A <strong>5-DOF</strong> model drops roll dynamics while keeping roll-coupled mass properties. The assumption is valid for:</p>
      <ul>
        <li><strong>Axis-symmetric launch vehicles</strong> whose roll is either uncontrollable or has negligible effect on guidance.</li>
        <li>Concept studies where pitch–yaw motion and translation dominate performance metrics (e.g. altitude, range, attitude for TVC).</li>
      </ul>
     <p> The roll moments where neglected as when introduced created a bug, likely to do with some other part of the code, feel free to experiment and let me know if you can solve it! </p>

<!-- Why Simulink? -->
<section id="why-simulink" class="py-16 px-6 md:px-12 max-w-5xl mx-auto">
  <h2 class="text-3xl font-extrabold text-white mb-6">Why Learn Simulink?</h2>
  <p class="text-lg text-gray-300 mb-6">
    Simulink isn’t just a toy — it’s a core tool used across the aerospace, automotive, and energy industries. From SpaceX to Siemens, Simulink powers control loops, system models, and rapid prototyping. By learning it now, you’re building a skillset that will:
  </p>
  <ul class="list-disc list-inside text-gray-300 mb-6 space-y-2">
    <li>💼 <strong>Impress recruiters</strong> — simulation and model-based design are key talking points in interviews.</li>
    <li>🎓 <strong>Accelerate coursework</strong> — especially at Caledonian where control systems, dynamics, and embedded applications often rely on MATLAB &amp; Simulink.</li>
    <li>🚀 <strong>Empower your own projects</strong> — from rockets to robotic arms to drones, you’ll be able to model, simulate, and iterate fast.</li>
  </ul>
  <p class="text-lg text-gray-300 mb-4">Some real-world systems modelled in Simulink include:</p>
  <ul class="list-disc list-inside text-gray-300 mb-6 space-y-1">
    <li>Jet engine control loops</li>
    <li>EV drivetrain dynamics and regenerative braking</li>
    <li>Satellite attitude controllers</li>
    <li>Wind-turbine pitch/yaw optimisation</li>
  </ul>
<div class="bg-gray-800 border-l-4 border-accent-red rounded-xl p-5 mb-6 shadow-lg">
  <p class="text-sm uppercase text-accent-red font-bold mb-2">Craig’s Perspective</p>
  <p class="text-gray-300 mb-3">
    For me, creating models for rockets allowed the testing and simulation of control systems such as Model Predictive Control. The aerospace industry has consistently fostered incredible innovation throughout history; today's industry continues this trend through the development of rovers and spacecraft. These autonomous machines have been essential in the quest to understand the universe and to obtain intimate knowledge of the planets within the solar system.
  </p>
  <p class="text-gray-300 mb-3">
    The James Webb Space Telescope, for instance, has groundbreakingly observed planets and celestial objects even beyond this solar system with unprecedented detail. At the core of interplanetary space missions—be it for a spacecraft, a rover, or a quadcopter—lie extremely sophisticated control systems. These require balancing diverse constraints while operating in stunningly unique and hostile conditions.
  </p>
  <p class="text-gray-300">
    Simulations can be designed to test these systems within the very physics they will face, with many planets and moons presenting difficult conditions to emulate on Earth. As with any engineering challenge, a trade-off arises in control systems: balancing the sufficient computational speed required to respond to real-time disturbances against precise, persistent control inputs. At the field's cutting edge, Thrust Vector Control (TVC) is deployed by SpaceX in Starship’s 39 Raptor engines (including the Super Heavy booster), alongside active aerodynamic surfaces to stabilise and guide the rocket across its flight stages.
  </p>
</div>

</section>

     <div class="callout bg-yellow-100 border-l-4 border-yellow-400 text-yellow-800 p-4 rounded-lg shadow-sm">
  ⚠️ <strong>Disclaimer</strong> — This tutorial is a starting point. It may contain minor bugs or assumptions that don’t hold for all rockets, or possibly plain inaccurate, but it’s <em>good enough to get you simulating</em>, thinking, and experimenting like a control engineer.

  <br><br>

  🚀 If you want deeper technical insight into real-world rocket performance — from stability margins to motor curves — we highly recommend checking out the <a href="https://openrocket.info/documentation.html" target="_blank" class="underline font-semibold text-blue-600 hover:text-blue-800">OpenRocket documentation</a>. It’s a brilliant, open-source tool with rich modelling features and detailed documentation that informed all of this work.
</div>

<div class="mt-8 text-center">
  <p class="mb-4 text-lg font-medium text-gray-800 dark:text-gray-200">
    📘 Furthermore, an academic piece was written on the equations and theory behind the simulation design.
  </p>
  <a href="T6dofTutorial.html" class="inline-block bg-[color:var(--rocket-red)] text-white font-semibold text-sm uppercase tracking-wide px-6 py-3 rounded-xl shadow-lg hover:bg-red-600 transition duration-300">
    View the Full 6-DOF Tutorial
  </a>
</div>

      <!-- 1 · Equation Set -->
      <h2 id="equations">1 · Equation Set</h2>
      <p>This is the function at the core of the simulation: a quaternion-based, body-frame-aware rigid-body dynamic model for translation and rotation.</p>

      <pre><code>function [pdd, wd, qd] = EOM(m, Fxyz, q_in, w1, w2, w3, Mb)

q_in = q_in / norm(q_in);
Ix=0.00083; Iy=0.00073; Iz=0.00073;
g=9.81;
wx=w1; wy=w2; wz=w3;
w=[w1;w2;w3];

% Newton-Euler rotation
wxd = (1/Ix) * (Mb(1) + (Iy - Iz) * wy * wz);
wyd = (1/Iy) * (Mb(2) + (Iz - Ix) * wx * wz);
wzd = (1/Iz) * (Mb(3) + (Ix - Iy) * wx * wy);
wd =[wxd;wyd;wzd];

% Quaternion rate
qd = 0.5*hamilton(q_in,[0;wx;wy;wz]);

% Rotate net force into inertial frame
Fi_quat = hamilton(hamilton(q_in,[0;Fxyz]), conjugate(q_in));
Fi = Fi_quat(2:4);

% Translational accelerations
xdd = (Fi(1) / m) - g;
ydd =  Fi(2) / m;
zdd =  Fi(3) / m;
pdd = [xdd; ydd; zdd];

function product = hamilton(q, r)
    product = [r(1)*q(1) - r(2)*q(2) - r(3)*q(3) - r(4)*q(4);
               r(1)*q(2) + r(2)*q(1) + r(3)*q(4) - r(4)*q(3);
               r(1)*q(3) - r(2)*q(4) + r(3)*q(1) + r(4)*q(2);
               r(1)*q(4) + r(2)*q(3) - r(3)*q(2) + r(4)*q(1)];
end

function q_star = conjugate(q)
    q_star = [q(1); -q(2); -q(3); -q(4)];
end

end</code></pre>

      <div class="callout">🧠 <strong>Note</strong> — This EOM uses a quaternion-based attitude representation to avoid gimbal lock and to cleanly rotate forces between frames. Euler angle rates are derived later in the Kinematics block.</div>
      <div class="callout">💡 <strong>Tip</strong> — Keeping φ as a constant parameter retains gravity-projection trig without adding a dynamic state.</div>

     <!-- 2 · Block-Diagram Topology -->
<h2 id="blocks">2 · Block-Diagram Topology</h2>
<ol class="space-y-8">
  <li>
    <strong> Top Level</strong> 
    <div class="flex justify-center mt-4">
      <img src="TutPage1Images/fullDiagram.png" alt="Platform Top Level" class="rounded border border-gray-700 dark:border-gray-300">
    </div>
  </li>
  <li>
    <strong>Environment</strong> 
    <div class="flex justify-center mt-4">
      <img src="TutPage1Images/enviroSub.png" alt="Environment Subsystem" class="rounded border border-gray-700 dark:border-gray-300">
    </div>
  </li>
  <li>
    <strong>Propulsion &amp; Mass</strong> 
    <div class="flex justify-center mt-4">
      <img src="TutPage1Images/RocketSub.png" alt="Propulsion and Mass Subsystem" class="rounded border border-gray-700 dark:border-gray-300">
    </div>
  </li>
  <li>
    <strong>Aerodynamics</strong> 
    <div class="flex justify-center mt-4">
      <img src="TutPage1Images/aeroSub.png" alt="Aerodynamics Subsystem" class="rounded border border-gray-700 dark:border-gray-300">
    </div>
  </li>
  <li>
    <strong>Attitude Kinematics</strong> 
    <div class="flex justify-center mt-4">
      <img src="TutPage1Images/rotationSub.png" alt="Attitude Kinematics Subsystem" class="rounded border border-gray-700 dark:border-gray-300">
    </div>
  </li>
  <li>
    <strong>Integrator and Stop Condition</strong> 
    <div class="flex justify-center mt-4">
      <img src="TutPage1Images/integrateSub.png" alt="TVC Actuator Subsystem" class="rounded border border-gray-700 dark:border-gray-300">
    </div>
  </li>
</ol>


      <!-- 3 · Step-by-Step Build -->
      <h2 id="build">3 · Step-by-Step Build</h2>

      <h3>Full 5-DOF Block Diagram</h3>
     
      <div class="my-8 flex justify-center" data-aos="fade-up">
        <img src="TutPage1Images/fullDiagram.png" alt="Rocket dynamics system" class="rounded border border-gray-700 dark:border-gray-300">
      </div>
      <p></p>


<p>
  Start by dropping a <strong>large Matlab Function Block</strong> and labelling it <strong>EOM</strong> (equations-of-motion); this will house the rigid-body ODEs later. Wire the sub-system structure (top-to-bottom) to match the whole system diagram above:
</p>

<ol>
  <li>
    <strong>Rocket</strong> subsystem’s <strong>Mass</strong> and <strong>T</strong> outputs.
  </li>
  <li>
    <strong>Environment</strong> subsystem’s <strong>Vb</strong> output (velocity-in-body) and feed the integrated acceleration as <strong>Vxyz</strong> (inertial frame) into its input along with the current quaternion, <strong>qin</strong>.
  </li>
  <li>
    <strong>Aerodynamics</strong> subsystem’s <strong>Fb</strong> and <strong>Mb</strong> output (body frame force and moments). Feed the angular velocity, <strong>w</strong> as an input along with body frame velocity, <strong>Vb</strong>.
  </li>
  <li>
    For now, leave the <strong>Thrust Vector Control</strong> subsystem disconnected.
  </li>
  <li>
    A two-way <strong>Sum</strong> block that collects aerodynamic forces, <strong>Fb</strong> and thrust, <strong>T</strong>.
  </li>
  <li>
    Feed the <strong>EOM's</strong> right-hand outputs (acceleration <strong>pdd</strong> and angular-rate derivative <strong>wd</strong>) into <strong>Integration/StopCondition</strong> (translation) and an <strong>Integrator</strong> feeding the <strong>Rotation</strong> subsystem. Finally, send position <strong>Xe</strong>, Euler angles and quaternions to an <strong>Animation</strong> subsystem for visualisation. Lay out the wires first, then drop the grey-shaded subsystems inside the white canvas exactly as shown.
  </li>
</ol>



      <h3>Environment Subsystem</h3>
            <div class="my-8 flex justify-center" data-aos="fade-up">
        <img src="TutPage1Images/enviroSub.png" alt="Environment dynamics system" class="rounded border border-gray-700 dark:border-gray-300">
      </div>
      <ol>
  <li>Begin with two <strong>Wind Speed</strong> Sine-Wave blocks.</li>
  <li>Low-pass them using <strong>Unit Delay</strong> blocks (<code>z⁻³</code>) for numerical accuracy during early stages of flight.</li>
  <li>A <strong>Vector Concatenate</strong> merges the wind components and a <strong>Constant</strong> block (zero) into a 3 × 1 vector <em>Vxyz</em>.</li>
  <li>Sum this with the inertial frame velocity using a <strong>Sum</strong> block marked “+ +” to obtain <em>Vrel</em> (relative wind).</li>
  <li>Pass <em>Vrel</em> and the incoming quaternion <em>q_in</em> into a MATLAB Function titled <em>l_to_b</em>.<pre><code>function Vb = I_to_b(V_rel_inertial, q_in)

q_in = q_in / norm(q_in);

% Transform velocity to body frame quaternion using current orientation
Vb_quat = hamilton(hamilton(conjugate(q_in), [0; V_rel_inertial]), q_in);
Vb = Vb_quat(2:4);  % Remove scalar part



%calculate conjugate of quaternion
    function q_star=conjugate(q)
        q_star=[q(1);-q(2);-q(3);-q(4)];
    end

end

function product = hamilton(q, r)
    product = [r(1)*q(1) - r(2)*q(2) - r(3)*q(3) - r(4)*q(4);
               r(1)*q(2) + r(2)*q(1) + r(3)*q(4) - r(4)*q(3);
               r(1)*q(3) - r(2)*q(4) + r(3)*q(1) + r(4)*q(2);
               r(1)*q(4) + r(2)*q(3) - r(3)*q(2) + r(4)*q(1)];
end

</code></pre></li>
  <li>Rotate the vector into body axes using <em>l_to_b</em>, yielding <em>Vb</em>.</li>
  <li>Probe the key signals with <strong>Scope</strong> blocks.</li>
  <li>Export <em>Vb</em> through an <strong>Outport</strong>.</li>
</ol>

      <h3>Propulsion &amp; Mass Subsystem</h3>
                  <div class="my-8 flex justify-center" data-aos="fade-up">
        <img src="TutPage1Images/RocketSub.png" alt="Rocket dynamics subsystem" class="rounded border border-gray-700 dark:border-gray-300">
      </div>
     <p><strong>Top branch (mass):</strong></p>
<ol>
  <li>Place a <strong>Constant</strong> (<em>-0.06194</em>) for propellant mass-flow rate into an <strong>Integrator (1/s)</strong>. (This depends on fuel velocity</li>
  <!-- Mass Flow Rate Explanation -->
<div class="bg-gray-900 text-gray-100 p-6 rounded-2xl shadow-md my-6">
  <h4 class="text-xl font-semibold mb-4">🔹 Two Ways to Estimate Mass Flow Rate (<em>&#x1E43;</em>)</h4>

  <ol class="space-y-4 list-decimal list-inside">
    <li>
      <strong>From Total Propellant Mass and Burn Time</strong><br>
      If you have:<br>
      <code>mₚ</code> = total propellant mass (kg)<br>
      <code>t_b</code> = total burn time (s)<br>
      <br>
      Then:<br>
      <code><strong>ṁ = mₚ / t_b</strong></code><br>
      This gives a constant average mass flow rate, which is a good approximation for most commercial model rocket motors.
    </li>

    <li>
      <strong>From Thrust and Exhaust Velocity</strong><br>
      If you have:<br>
      <code>T</code> = thrust (N)<br>
      <code>vₑ</code> = effective exhaust velocity (m/s)<br>
      <br>
      Then from the thrust equation:<br>
      <code>T = ṁ · vₑ ⇒ <strong>ṁ = T / vₑ</strong></code><br>
      <span class="italic">🧠 Note:</span> This assumes no atmospheric pressure contribution (or that it’s been factored into thrust).<br>
      Exhaust velocity can be estimated from:<br>
      <code><strong>vₑ = I<sub>sp</sub> · g₀</strong></code>
    </li>
  </ol>
</div>
  <li>Limit the result with a <strong>Saturation</strong> so mass never drops below zero.</li>
  <li>Sum it with a <strong>Constant 0.607 kg</strong> dry-mass using a two-input <strong>Sum</strong>.</li>
  <li>The summation of these blocks is the current <em>Mass</em> at each time step.</li>
</ol>

<p><strong>Bottom branch (thrust):</strong></p>
<ol>
  <li>Set up a <strong>1-D Lookup Table</strong> based off any typical thrust-time curve online. This is a small rocket and uses Thrust = [13;82;98;100;90;86;93;96;96;92;88;83;80;30;4;0] and Time = [0.01;0.02;0.03;0.04;0.05;0.06;0.12;0.2;0.3;0.7;0.9;1.07;1.1;1.2;1.3;1.33] which are stored in the base workspace.<strong></li>
  <li>Combine <em>Tx</em> with two <strong>Constant 0</strong> blocks in a <strong>Mux</strong> to form a 3-component thrust vector.</li>
  <li>Output the vector via <strong>Outport T</strong>. It is critical to note that the thrust is being applied in the body frame x axis, sometimes the z axis is used here.</li>
</ol>
      <h3>Aerodynamics Subsystem</h3>
                        <div class="my-8 flex justify-center" data-aos="fade-up">
        <img src="TutPage1Images/aeroSub.png" alt="Rocket dynamics subsystem" class="rounded border border-gray-700 dark:border-gray-300">
      </div>
  <ol>
 <ol>
  <li>Feed the 3-axis body velocity <em>Vb</em> into a MATLAB Function.</li>

  <li>
    The function outputs individual components (<em>Vx</em>, <em>Vy</em>, <em>Vz</em>) plus magnitude:<br><br>

    <div class="bg-gray-900 text-green-100 text-sm font-mono rounded-xl p-4 overflow-x-auto my-4 shadow-md">
      <pre><code>function [Vx, Vy, Vz, Vmag, VxAbs] = mag(Vb)

Vx = Vb(1);
Vy = Vb(2);
Vz = Vb(3);

VxAbs = abs(Vx);
Vmag = norm(Vb);

end</code></pre>
    </div>
  </li>

  <li>Use two <strong>If</strong> blocks to guard against negative <em>Vx</em>/<em>Vy</em> when computing AoA and Beta.</li>
  <li>Each branch contains a <strong>Gain</strong> and a <strong>Merge</strong>.</li>
  <li>Convert AoA and Beta from radians to degrees (x180/pi) for intuition.</li>
  <li>Bundle AoA, Beta, <em>Vb</em> and body rates <em>w</em> into the main aerodynamic-coefficients MATLAB Function block</li>
  <li>Deliver <em>Fb</em> and <em>Mb</em> to the calling level through <strong>Outports</strong>.</li>
</ol>


<!-- Lift, Side-Force & Drag Function -->
<h4>Lift, Side-Force &amp; Drag Function</h4>
<ol>
  <li>The following MATLAB function computes aerodynamic forces (<code>Flift</code>, <code>Fside</code>, <code>Fdrag</code>) and moments (<code>Mb</code>).</li>
  <li>It uses inputs: angle-of-attack (<code>AoA</code>), sideslip angle (<code>Beta</code>), body-axis velocity (<code>Vb</code>), and angular-rates (<code>w</code>).</li>
  <li>Lift and side-force act perpendicularly, aligned to body frame axes.</li>
  <li>Forces are summed and inverted to match coordinate conventions.</li>
</ol>

<pre><code>function [Fb, Mb, Flift, Fside, Fdrag, Cn, Cs, CmpDamp, CmyDamp] = Lift(AoA, Beta, Vb, w)
% LIFT calculates aerodynamic forces and moments based on AoA, sideslip,
% body-frame velocity, and angular rates. Used in Aero block of 6DOF rocket sim.

% Geometry and constants
Ab = 0.003504635;            % Reference area (body cross-section)
Afin = 0.00965;              % Fin area
Aplanform = 0.0835;          % Total lifting planform area
l = 0.202;                   % Lever arm from CoG to CoP
Mroll = 0;                   % Roll moment (not modeled here)
rho = 1.225;                 % Air density
Cdx = 0.65;                  % Base drag coefficient
d = 0.068;                   % Reference length (rocket diameter)
Vbx = Vb(1); Vby = Vb(2); Vbz = Vb(3); % Velocity components
wy = w(2); wz = w(3);        % Angular rates (pitch & yaw)
span = 0.1;                  % Fin span
midchord = (90 - 85.134)*pi/180; % Mid-chord sweep angle (rad)
K = 1.1;                     % Empirical lift correction factor

% Flow properties
AoAThreshold = 5*pi/180;     % Linear vs nonlinear lift region (5 deg)
Vmag = norm(Vb);             % Total airspeed
q = 0.5 * rho * Vmag^2;      % Dynamic pressure
M = Vmag / 340;              % Mach number
r = d / 2;                   % Body radius

if M > 1, M = 0.99; end      % Avoid sqrt(1-M^2) becoming complex

% Compressibility-adjusted aspect ratio factor (used in lift curve slope)
rho = span^2 * sqrt(1 - M^2) / (Afin * cos(midchord));

%% --- AoA-dependent Lift Coefficient (Cn) ---
if abs(AoA) < AoAThreshold
    % Linear region: only nose and fin effects
    CnNose = 2*sin(AoA)/Ab * pi*0.229^2;
    Cnfins = 3*(2*pi*span^2/Ab)/(1 + sqrt(1 + rho^2));
    CnAoA = CnNose + Cnfins;
    Cn = CnAoA * -sin(AoA);   % Negated for coordinate convention
else
    % Nonlinear region: includes body lift ~ sin^2(AoA)
    CnNose = 2*sin(AoA)/Ab * pi*0.229^2;
    Cnfins = 3*(2*pi*span^2/Ab)/(1 + sqrt(1 + rho^2));
    CnBodyLift = K * Aplanform / Ab * sin(AoA)^2;  % Nonlinear lift
    CnAoA = CnNose + Cnfins + CnBodyLift;
    Cn = CnAoA * -sin(AoA);   % Overall normal force coefficient
end

%% --- Beta-dependent Side Force Coefficient (Cs) ---
if abs(Beta) < AoAThreshold
    % Linear sideslip region
    CsNose = 2*sin(Beta)/Ab * pi*0.229^2;
    Csfins = 3*(2*pi*span^2/Ab)/(1 + sqrt(1 + rho^2));
    CsBeta = CsNose + Csfins;
    Cs = CsBeta * sin(Beta);
else
    % Nonlinear sideslip response: adds body lift effect
    CsNose = 2*sin(Beta)/Ab * pi*0.229^2;
    Csfins = 3*(2*pi*span^2/Ab)/(1 + sqrt(1 + rho^2));
    CsBodyLift = K * Aplanform / Ab * sin(Beta)^2;
    CsBeta = CsNose + Csfins + CsBodyLift;
    Cs = CsBeta * sin(Beta);
end

%% --- Pitch and Yaw Moment Coefficients ---
Cmp = (Cn * l) / d;          % Pitch moment from Cn
Cmy = (Cs * l) / d;          % Yaw moment from Cs

% Angular rate damping (dynamic stability): increases with rate^2
CmpDamp = -(1.25^4 * r * -wy^2) / (Ab * d * Vmag^2); % pitch rate damping
CmyDamp =  (1.25^4 * r * -wz^2) / (Ab * d * Vmag^2); % yaw rate damping

% Combine static and damping moments
Cmp = Cmp + CmpDamp;
Cmy = Cmy + CmyDamp;

%% --- Aerodynamic Forces ---
if Vmag > 1e-3
    % Drag force based on total velocity direction
    Fdragmagx = q * Ab * Cdx;
    Fdragx = Fdragmagx * (Vbx / Vmag * sign(Vbx));  % x-component
    Fdragyz = Fdragmagx * ([Vby * sign(Vby); Vbz * sign(Vbz)] / Vmag);  % y/z

    Fdrag = [Fdragx; Fdragyz];       % Total drag vector (body frame)
    Flift = q * Ab * Cn;             % Lift from AoA
    Fside = q * Ab * Cs;             % Side force from Beta
    Mpitch = q * Ab * d * Cmp;       % Pitching moment
    Myaw = q * Ab * d * Cmy;         % Yawing moment
else
    % Near-zero speed: no aerodynamic force
    Fdrag = [0;0;0]; Flift = 0; Fside = 0; Mpitch = 0; Myaw = 0;
end

%% --- Outputs ---
% Combine lift, side-force, and drag in body frame
Fb = [0; -Fside; Flift] - Fdrag;     % Net aerodynamic force (body frame)
Mb = [Mroll; -Mpitch; -Myaw];        % Net aerodynamic moment
end
</code></pre>



<!-- Fig-5 -->
<h3>Attitude Kinematics Subsystem</h3>
<div class="my-8 flex justify-center" data-aos="fade-up">
  <img src="TutPage1Images/rotationSub.png" alt="Rotation subsystem" class="rounded border border-gray-700 dark:border-gray-300">
</div>
<ol class="list-decimal list-inside space-y-2">
  <li>Bring the quaternion <em>Q</em> in through an <strong>Inport</strong>.</li>
  <li>Square-and-sum it using a <strong>Math Function |u|²</strong> block.</li>
  <li>A <strong>Compare to Zero</strong> block detects if the norm is zero and opens a bypass path to avoid NaNs.</li>
  <li>The validated quaternion is passed into a MATLAB Function block titled <em>q [R₁,R₂,R₃]</em> (Rotation Order XYZ) which outputs Euler angles.</li>
  <li>Insert a small <strong>Gain −1</strong> to flip the sign convention before sending to the <strong>Outport Euler angles</strong> (feeding the 6dof simulation block which works best option for quick simulation results).</li>
  <li>In parallel, feed <em>Q</em> into another MATLAB Function block that converts quaternion → axis-angle, outputting via <strong>axis angles</strong> Outport.</li>
  <li>Also send <em>Q</em> into a <strong>Quaternion to DCM</strong> block and export the Direction Cosine Matrix through <strong>Outport DCM_be</strong>.</li>
</ol>

<!-- Fig-6 -->
<h3>Integration / Stop-Condition Subsystem</h3>
<div class="my-8 flex justify-center" data-aos="fade-up">
  <img src="TutPage1Images/integrateSub.png" alt="Integration subsystem" class="rounded border border-gray-700 dark:border-gray-300">
</div>

<p><strong>Top path (attitude):</strong></p>
<ol class="list-decimal list-inside space-y-2">
  <li>Integrate angular-rate derivative <em>wd</em> using an <strong>Integrator</strong> to get body-rates <em>w</em>.</li>
  <li>Pass <em>w</em> into a second <strong>Integrator</strong> to accumulate Euler angle <em>theta</em>.</li>
  <li>Attach <strong>Scope</strong> blocks to both integrators to visualise <em>w</em> and <em>theta</em>.</li>
</ol>

<p><strong>Bottom path (translation):</strong></p>
<ol class="list-decimal list-inside space-y-2">
  <li>Integrate acceleration <em>pdd</em> once to obtain <em>Velocity</em>.</li>
  <li>Integrate <em>Velocity</em> again to obtain <em>Dis</em> (displacement).</li>
  <li>Route <em>Vx</em> and <em>Xx</em> into a nested <strong>Stop Condition</strong> subsystem.</li>
  <li>Use two <strong>Relational Operator</strong> blocks to check the thresholds: “&lt; −3 m/s” and “≤ −1.5 m”.</li>
  <li>The results feed into an <strong>AND</strong> block that triggers a <strong>Stop Simulation</strong> block.</li>
  <li>Multiplex the position components using a <strong>Mux</strong> block.</li>
  <li>Apply a <strong>Gain 10</strong> to scale the position signal for the visualiser (producing <em>myTranslation</em>. (I never got this working well).</li>
  <li>If your inertial frame requires it, flip the sign of <em>Xe</em> using a simple <strong>Gain −1</strong>.</li>
</ol>


    <!-- ====================== FOOTER ====================== -->
    <footer class="border-t border-gray-800 dark:border-gray-700 py-8 text-center text-sm text-gray-500 dark:text-gray-400">
      © 2025 Craig Andrews · Caledonian Rocketry
    </footer>

    <!-- Init AOS -->
    <script> AOS.init({ duration: 800, once: true }); </script>

    <!-- ★★ Star-field JS -->
    <script>
      document.addEventListener('DOMContentLoaded',()=>{
        const c=document.getElementById('starfield'),ctx=c.getContext('2d'),
              DPR=window.devicePixelRatio||1,
              L=[{n:60,s:.06,z:1.6},{n:120,s:.03,z:1.1},{n:180,s:.015,z:.8}];
        let W,H,S=[],tx=0,ty=0,last=0;
        const R=()=>{W=c.width=innerWidth*DPR;H=c.height=innerHeight*DPR;ctx.scale(DPR,DPR);S=[];
          L.forEach(l=>{for(let i=0;i<l.n;i++)S.push({x:Math.random()*innerWidth,y:Math.random()*innerHeight,l,phi:Math.random()*360})})};
        const draw=t=>{
          ctx.clearRect(0,0,W,H);
          if(t-last>600+Math.random()*600){last=t;const n=1+Math.floor(Math.random()*3);
            for(let k=0;k<n;k++){const v=4+Math.random()*4;
              S.push({m:1,x:-200-Math.random()*150,y:Math.random()*innerHeight*.7,vx:v,vy:v*.15,len:120+Math.random()*80})}}
          S.forEach((s,i)=>{
            if(s.m){
              ctx.strokeStyle='rgba(255,255,255,.85)';ctx.lineWidth=2;
              ctx.beginPath();ctx.moveTo(s.x,s.y);ctx.lineTo(s.x-s.len,s.y-s.len*.2);ctx.stroke();
              s.x+=s.vx;s.y+=s.vy;s.len*=.985;if(s.x>innerWidth+200)S.splice(i,1);return;}
            const px=s.x+tx*s.l.s*30,py=s.y+ty*s.l.s*30,
                  a=.6+.4*Math.sin(t/1000+s.phi),
                  h=200+55*Math.sin(t/1500+s.phi);
            ctx.fillStyle=`hsla(${h},100%,88%,${a})`;
            ctx.fillRect(px,py,s.l.z,s.l.z);
            s.y+=s.l.s*16;if(s.y>innerHeight)s.y=0;});
          requestAnimationFrame(draw);};
        addEventListener('pointermove',e=>{tx=e.clientX/innerWidth-.5;ty=e.clientY/innerHeight-.5},{passive:true});
        addEventListener('deviceorientation',e=>{if(e.beta!=null){tx=e.gamma/20;ty=e.beta/40}},{passive:true});
        R();requestAnimationFrame(draw);addEventListener('resize',R);
      });
    </script>
  
</div>
</body>
</html>
